# gopl 读书笔记
> 关键点记录一下

### 2.3 变量

- 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导
- 如果初始化表达式被省略，那么将用零值初始化该变量。
- 数值类型变量对应的零值是0
- 布尔类型变量对应的零值是false
- 字符串类型对应的零值是空字符串
- 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil
- 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值
- 在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。
- 任何类型的指针的零值都是nil

- 如果指针p指向某个有效变量，那么p != nil测试为真
- 指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等
- 并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址, 变量有时候被称为可寻址的值
- 返回函数中局部变量的地址也是安全的

- 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T
- 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外
- 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的
- 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和 [0]int, 有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）
- 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型

- 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的


### 2.5 类型

- 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)）。
- 只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
- 如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。


### 2.7 作用域
- 句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。
- 句法块内部声明的名字是无法被外部块访问的。
- 对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
- 任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。
- 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。

![Visitor Count](https://profile-counter.glitch.me/brotherbigbao/count.svg)