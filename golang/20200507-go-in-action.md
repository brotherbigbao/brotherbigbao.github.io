# Go In Action 读书笔记
> 关键点记录一下

## 第2章

- 通道（channel）和映射（map）与切片（slice）一样，也是引用类型。  p17

- 在Go语言中，所有的变量都以值的方式传递，因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值，
所以依旧被看作以值的方式在传递。 p19

- WaitGroup的值没有作为参数传入匿名函数，但是匿名函数依旧访问到了这个值。Go语言支持新闭包，这里就应用了闭包。实际上，
在匿名函数内访问searchTerm和results变量，也是通过闭包的形式访问的。因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。
匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量本身。
因为matcher和feed变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量。 p20

- 因为Go编译器可以根据赋值运算符右边的值来推导类型，声明常量的时候不需要指定类型。

- type defaultMatcher struct{}  空结构在创建实例时，不会分配任何内存。

- 如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的类型绑在一起。
在我们的例子里，Search方法与defaultMatcher类型的值绑在一起。
这意味着我们可以使用defaultMatcher类型的值或者指向这个类型值的指针来调用Search方法。
无论我们是使用接收者类型的值来调用这个方法，还是使用接收者类型值的指针来
调用这个方法，编译器都会正确地引用或者解引用对应的值，作为接收者传递给Search方法。P26

- 因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。对于defaultMatcher类型来说，
使用值作为接收者是因为创建一个defaultMatcher类型的值不需要分配内存。
由于defaultMatcher不需要维护状态，所以不需要指针形式的接收者。 P27

- 与直接通过值或指针调用方法不同，如果通过接口类型的值调用方法，规则有很大不同。
使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。
使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。 P27 (第5章有详细说明)

## 第4章

- 在Go语言里，数组是一个值。这意味着数组可以用在赋值操作中。变量名代表整个数组，因此，同样类型的数组可以赋值给另一个数组。
数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。

- 切片，如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个append操作创建新的底层数组，与原有的底层数组分离。
新切片与原有的底层数组分离后，可以安全地进行后续修改。 p65
```
对底层数组容量是k的切片slice[i:j]来说

长度：j - i
容量：k - i
```

```
对于slice[i:j:k] 或 [2:3:4]

长度：j - i 或 3 - 2 = 1
容量：k - i 或 4 - 2 = 2
```

- 两个切片追加

```
// 创建两个切片，并分别用两个整数进行初始化
s1 := []int{1, 2}
s2 := []int{3, 4}

// 将两个切片追加在一起，并显示结果
fmt.Printf("%v\n", append(s1, s2...))

Output:
[1 2 3 4]
```

- 当迭代切片时，关键字range会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本。
需要强调的是，range创建了每个元素的副本，而不是直接返回对该元素的引用。P72

- 在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本也很低。
由于切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。
复制时只会复制切片本身，不会涉及底层数组。 P75

- 可以通过声明一个未初始化的映射来创建一个值为nil的映射（称为nil映射）。nil映射不能用于存储键值对，否则，会产生一个语言运行时错误。P79

- 在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，
所有对这个映射的引用都会察觉到这个修改。P81

- 数组是构造切片和映射的基石。将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。 P82

## 第5章

- 两种不同类型的值即便互相兼容，也不能互相赋值。编译器不会对不同类型的值做隐式转换。 P86

- 方法。Go语言里有两种类型的接收者：值接收者和指针接收者。 P88

- 如果使用值接收者声明方法，调用时会使用这个值的一个副本来执行。 P88

- 也可以使用指针来调用使用值接收者声明的方法，Go语言调整了指针的值，来符合方法接收者的定义。
可以认为Go语言执行了代码清单5-18所示的操作。
代码5-18：(*lisa).notify()     P89

- 代码清单5-18展示了Go编译器为了支持这种方法调用背后做的事情。指针被解引用为值，这样就符合了值接收者的要求。再强调一次，notify操作的是
一个副本，只不过这次操作的是从lisa指针指向的值的副本。    P89

- 当调用使用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值。 P89

- 总结一下，值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法。 P90

- 在声明一个新类型之后，声明一个该类型的方法之前，需要先回答一个问题：这个类型的本质是什么。
如果给这个类型增加或者删除某个值，是要创建一个新值，还是要更改当前的值？如果是要创建一个新值，该类型的方法
就使用值接收者。如果是要修改当前值，就使用指针接收者。
这个答案也会影响程序内部传递这个类型的值的方式：是按值传递，还是按指针做传递。保持传递的一致性很重要。   P90
 
- Go语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。
当声明上述类型的变量时，创建的变量被称作标头（header）值。从技术细节上说，字符串也是一种引用类型。
每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特
的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用
类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是
在共享底层数据结构。 P91

- 阻止复制 可以在代码清单 5-31 里看到标准库中声明的 File 类型。这个类型的本质是非原始的。这
个类型的值实际上不能安全复制。对内部未公开的类型的注释，解释了不安全的原因。因为没有
方法阻止程序员进行复制，所以 File 类型的实现使用了一个嵌入的指针，指向一个未公开的类
型。本章后面会继续探讨内嵌类型。正是这层额外的内嵌类型阻止了复制。不是所有的结构类型
都需要或者应该实现类似的额外保护。程序员需要能识别出每个类型的本质，并使用这个本质来
决定如何组织类型。
```
type File struct {
    *file
}
```

- 从接收者类型的角度来看方法集 代码清单 5-43 展示了同样的规则，只不过换成了接收者的视角。这个规则说，如果使用指
针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值
接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。
现在的问题是，为什么会有这种限制？事实上，编译器并不是总能自动获得一个值的地址  P102
```
Methods Receivers Values
-----------------------------------------------
(t T) T and *T
(t *T) *T
```

- 嵌入类型 公开或未公开的类型  略



![Visitor Count](https://profile-counter.glitch.me/brotherbigbao/count.svg)